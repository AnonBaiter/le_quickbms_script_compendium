# SquareSoft/Square Enix - .dat(/.sz) movie format
# almost all variations supported at the moment, although this script still has a long way to go

open FDDE "dat" 0
open FDDE "sz" 1 EXISTS

get DAT_SIZE asize
get NAME basename

if EXISTS != 0
	# "paired" .sz/.dat movies
	math dat_chunk_offset = 0
	math intra_quantizer_offset = 0
	math non_intra_quantizer_offset = 0x40
	for quantizer = 0 < 0x40
		goto intra_quantizer_offset 1
		get intra_byte byte 1
		math intra_quantizer_offset + 1
		putarray 101 quantizer intra_byte
		goto non_intra_quantizer_offset 1
		get non_intra_byte byte 1
		math non_intra_quantizer_offset + 1
		putarray 102 quantizer non_intra_byte
	next quantizer
	log MEMORY_FILE 0 0
	for i = 0
		putarray 0 0 dat_chunk_offset
		get dat_chunk_size long 1
		if dat_chunk_size = 0
			break
		else
			log MEMORY_FILE dat_chunk_offset dat_chunk_size 0
			math dat_chunk_position = 0
			do
				math sound_type = 0
				goto dat_chunk_position MEMORY_FILE
				get chunk_track_info_01 long MEMORY_FILE
				get chunk_track_info_02 long MEMORY_FILE
				get chunk_track_info_03 long MEMORY_FILE
				get chunk_track_info_04 long MEMORY_FILE
				savepos raw_track_offset_within_chunk MEMORY_FILE
				math dat_chunk_position + 0x10
				if chunk_track_info_01 == 0x40
					math sound_type = 2
					callfunction sound_handle 1
					math dat_chunk_position + chunk_track_info_03
				elif chunk_track_info_01 >= 0x50 && chunk_track_info_01 <= 0x51
					math sound_type = 3
					callfunction sound_handle 1
					math dat_chunk_position + chunk_track_info_03
				else
					if chunk_track_info_01 == chunk_track_info_02
					if chunk_track_info_02 == chunk_track_info_03
					if chunk_track_info_03 == chunk_track_info_04
						if chunk_track_info_01 != 0
							math sound_type = 1
						endif
					endif
					endif
					endif
					if sound_type != 0
						callfunction sound_handle 1
					endif
					math dat_chunk_position + chunk_track_info_01
				endif
			while dat_chunk_position < dat_chunk_size
			math dat_chunk_offset + dat_chunk_size
			log MEMORY_FILE 0 0
		endif
	next i

	startfunction sound_handle
		if sound_type = 1
			math is_vag = 0
			math is_pcm = 0
			math is_pcm_and_ac3 = 0
			math bilingual = 0
			# PS-ADPCM/VAG-like audio codec with 16 extra bytes each chunk
			if chunk_track_info_01 == 0x1c30
				math is_vag = 1
				math vag_chunksize = chunk_track_info_01
			endif
			if chunk_track_info_01 == 0x3860
				math is_vag = 1
				math bilingual = 1
				math vag_chunksize_per_language = 0x1c30
			endif
			# individual PCM16 chunks
			if chunk_track_info_01 == 0x3c00
				math is_pcm = 1
				math pcm_chunksize = chunk_track_info_01
			endif
			if chunk_track_info_01 == 0x6400
				math is_pcm = 1
				math pcm_chunksize = chunk_track_info_01
			endif
			if chunk_track_info_01 == 0x7800
				math is_pcm = 1
				math bilingual = 1
				math pcm_chunksize_per_language = 0x3c00
			endif
			if chunk_track_info_01 == 0xc800
				math is_pcm = 1
				math bilingual = 1
				math pcm_chunksize_per_language = 0x6400
			endif
			# PCM16+AC-3 chunks
			if chunk_track_info_01 == 0x5110
				math is_pcm_and_ac3 = 1
				math pcm_chunksize = 0x3c00
				math ac3_chunksize = 0x1510
			endif
			if chunk_track_info_01 == 0x8000
				math is_pcm_and_ac3 = 1
				math pcm_chunksize = 0x6400
				math ac3_chunksize = 0x1c00
			endif
			if chunk_track_info_01 == 0x8400
				math is_pcm_and_ac3 = 1
				math pcm_chunksize = 0x6400
				math ac3_chunksize = 0x2000
			endif
			if chunk_track_info_01 == 0x8700
				math is_pcm_and_ac3 = 1
				math pcm_chunksize = 0x6400
				math ac3_chunksize = 0x2300
			endif
			if chunk_track_info_01 == 0xa220
				math is_pcm_and_ac3 = 1
				math bilingual = 1
				math pcm_chunksize_per_language = 0x3c00
				math ac3_chunksize_per_language = 0x1510
			endif
			if chunk_track_info_01 == 0x10800
				math is_pcm_and_ac3 = 1
				math bilingual = 1
				math pcm_chunksize_per_language = 0x6400
				math ac3_chunksize_per_language = 0x2000
			endif
			if is_vag = 1
				append
				if bilingual = 0
					string vag_name p "%s.vag" NAME
					log vag_name raw_track_offset_within_chunk vag_chunksize MEMORY_FILE
				elif bilingual = 1
					math vag_language_track_offset_within_chunk = raw_track_offset_within_chunk
					for language = 0 < 2
						xmath language2 "language + 1"
						string vag_name p "%s[%02d].vag" NAME language2
						log vag_name vag_language_track_offset_within_chunk vag_chunksize_per_language MEMORY_FILE
						math vag_language_track_offset_within_chunk + vag_chunksize_per_language
					next language
				endif
				append
			endif
			if is_pcm = 1
				append
				if bilingual = 0
					string pcm_name p "%s.pcm" NAME
					log pcm_name raw_track_offset_within_chunk pcm_chunksize MEMORY_FILE
				elif bilingual = 1
					math pcm_language_track_offset_within_chunk = raw_track_offset_within_chunk
					for language = 0 < 2
						xmath language2 "language + 1"
						string pcm_name p "%s[%02d].pcm" NAME language2
						log pcm_name pcm_language_track_offset_within_chunk pcm_chunksize_per_language MEMORY_FILE
						math pcm_language_track_offset_within_chunk + pcm_chunksize_per_language
					next language
				endif
				append
			endif
			if is_pcm_and_ac3 = 1
				append
				if bilingual = 0
					string pcm_name p "%s.pcm" NAME
					log pcm_name raw_track_offset_within_chunk pcm_chunksize MEMORY_FILE
					string ac3_name p "%s.ac3" NAME
					xmath ac3_offset "pcm_chunksize + raw_track_offset_within_chunk"
					xmath ac3_last_offset "(ac3_offset + ac3_chunksize) - 8"
					for
						goto ac3_last_offset MEMORY_FILE
						get zero_byte_01 long MEMORY_FILE
						get zero_byte_02 long MEMORY_FILE
						if zero_byte_02 = 0
							math ac3_chunksize - 4
						else
							break
						endif
						if zero_byte_01 = 0
							math ac3_chunksize - 4
						else
							break
						endif
						math ac3_last_offset - 8
					next
					log ac3_name ac3_offset ac3_chunksize MEMORY_FILE
				elif bilingual = 1
					math pcm_language_track_offset_within_chunk = raw_track_offset_within_chunk
					for language = 0 < 2
						xmath language2 "language + 1"
						string pcm_name p "%s[%02d].pcm" NAME language2
						putarray 1 language pcm_name
						putarray 3 language pcm_language_track_offset_within_chunk
						math pcm_language_track_offset_within_chunk + pcm_chunksize_per_language
					next language
					math ac3_language_track_offset_within_chunk = pcm_language_track_offset_within_chunk
					for language = 0 < 2
						xmath language2 "language + 1"
						string ac3_name p "%s[%02d].ac3" NAME language2
						putarray 2 language ac3_name
						putarray 4 language ac3_language_track_offset_within_chunk
						math ac3_language_track_offset_within_chunk + ac3_chunksize_per_language
					next language
					for language = 0 < 2
						getarray pcm_name 1 language
						getarray ac3_name 2 language
						getarray pcm_language_track_offset_within_chunk 3 language
						getarray ac3_language_track_offset_within_chunk 4 language
						log pcm_name pcm_language_track_offset_within_chunk pcm_chunksize_per_language MEMORY_FILE
						math ac3_actual_chunksize = ac3_chunksize_per_language
						xmath ac3_last_offset "(ac3_language_track_offset_within_chunk + ac3_chunksize_per_language) - 8"
						for
							goto ac3_last_offset MEMORY_FILE
							get zero_byte_01 long MEMORY_FILE
							get zero_byte_02 long MEMORY_FILE
							if zero_byte_02 = 0
								math ac3_actual_chunksize - 4
							else
								break
							endif
							if zero_byte_01 = 0
								math ac3_actual_chunksize - 4
							else
								break
							endif
							math ac3_last_offset - 8
						next
						log ac3_name ac3_language_track_offset_within_chunk ac3_actual_chunksize MEMORY_FILE
					next language
				endif
				append
			endif
		elif sound_type = 2
			append
			string pcm_name p "%s.adpcm" NAME
			log pcm_name raw_track_offset_within_chunk chunk_track_info_02 MEMORY_FILE
			if chunk_track_info_04 != 0
				xmath ac3_offset "(chunk_track_info_03 - chunk_track_info_04) + raw_track_offset_within_chunk"
				string ac3_name p "%s.ac3" NAME
				log ac3_name ac3_offset chunk_track_info_04 MEMORY_FILE
			endif
			append
		elif sound_type = 3
			log MEMORY_FILE2 raw_track_offset_within_chunk chunk_track_info_03 MEMORY_FILE
			callfunction process_compressed_audio_chunk 1
			append
			if decompressed_size == chunk_track_info_02
				string pcm_name p "%s.adpcm" NAME
				log pcm_name 0 chunk_track_info_02 MEMORY_FILE3
				log MEMORY_FILE3 0 0
				if chunk_track_info_04 != 0
					xmath ac3_offset "(chunk_track_info_03 - chunk_track_info_04) + raw_track_offset_within_chunk"
					string ac3_name p "%s.ac3" NAME
					log ac3_name ac3_offset chunk_track_info_04 MEMORY_FILE
				endif
			endif
			append
		endif
	endfunction
	
	startfunction process_compressed_audio_chunk
		get compression_level byte MEMORY_FILE2
		if compression_level >= 1 && compression_level <= 2
		endif
		get original_size long MEMORY_FILE2
		log MEMORY_FILE3 0 0
		math bytes_written = 0
		xmath full_size "chunk_track_info_03 - chunk_track_info_04"
		do
			get control_byte byte MEMORY_FILE2
			if control_byte <= 0x7d
				for j = 0 < control_byte
					goto bytes_written MEMORY_FILE3
					get bytes_to_write byte MEMORY_FILE2
					put bytes_to_write byte MEMORY_FILE3
					math bytes_written + 1
				next j
			elif control_byte == 0x7e
				get bytes_to_write byte MEMORY_FILE2
				math bytes_to_write + 4
				get source_byte_to_write byte MEMORY_FILE2
				for j = 0 < bytes_to_write
					goto bytes_written MEMORY_FILE3
					put source_byte_to_write byte MEMORY_FILE3
					math bytes_written + 1
				next j
			elif control_byte == 0x7f
				get bytes_to_write short MEMORY_FILE2
				get source_byte_to_write byte MEMORY_FILE2
				for j = 0 < bytes_to_write
					goto bytes_written MEMORY_FILE3
					put source_byte_to_write byte MEMORY_FILE3
					math bytes_written + 1
				next j
			elif control_byte >= 0x80
				xmath additional_control_byte_01 "((control_byte & 0x7f) >> 3) + 3"
				if compression_level == 2
					if additional_control_byte_01 >= 5
						xmath additional_control_byte_03 "((additional_control_byte_01 - 5) >> 1) + 1"
						math additional_control_byte_01 - additional_control_byte_03
					endif
				endif
				if compression_level == 1
					xmath additional_control_byte_02 "control_byte & 0x07"
				elif compression_level == 2
					xmath additional_control_byte_02 "control_byte & 0x0f"
				endif
				if additional_control_byte_02 >= 0x08
					math additional_control_byte_01 - 1
				endif
				get previous_bytes byte MEMORY_FILE2
				if additional_control_byte_02 == 0
					xmath byte_recovery_position "(bytes_written - previous_bytes) - 1"
				else
					xmath byte_recovery_position "(bytes_written - previous_bytes) - ((additional_control_byte_02 << 8) + 1)"
				endif
				for j = 0 < additional_control_byte_01
					if byte_recovery_position >= 0
						goto byte_recovery_position MEMORY_FILE3
						get recurring_bytes byte MEMORY_FILE3
					else
						math recurring_bytes = 0
					endif
					goto bytes_written MEMORY_FILE3
					put recurring_bytes byte MEMORY_FILE3
					math bytes_written + 1
					math byte_recovery_position + 1
				next j
			endif
			savepos current_position MEMORY_FILE2
		while current_position < full_size
		get decompressed_size asize MEMORY_FILE3
		log MEMORY_FILE2 0 0
	endfunction
else
	# "single" .DAT movies
	get single_dat_type long
	if single_dat_type == 0
		get dat_02 byte
		get dat_03 byte
		get dat_04 short
		get dat_05 long
		get video_height short
		get video_width short
		get dat_08 long
		get dat_09 long
		get dat_10 long
		get dat_11 long
		if dat_03 == 0xff
			get dat_12 long
		endif
		savepos chunk_position
		do
			goto chunk_position
			if dat_03 == 0xff
				get chunk_size long
				get chunk_number long
				math chunk_position + chunk_size
				math chunk_position + 8
			endif
			if dat_03 == 0x01
				get chunk_size_01 long
				get chunk_size_02 long
				get chunk_number long
				get chunk_04 long
				math chunk_position + chunk_size_02
				math chunk_position + 16
			endif
		while chunk_position < DAT_SIZE
	endif

	if single_dat_type == 1
		get dat_02 long
		get video_height short
		get video_width short
		get total_number_of_chunks long
		get dat_06 long
		get dat_07 long
		get dat_08 long
		get dat_09 long
		savepos chunk_position
		do
			goto chunk_position
			if chunk_position == 0x20
				get chunk_track_number long
				get chunk_size_per_track long
				get chunk_02 long
				get chunk_03 long
				if chunk_track_number == 2
					savepos chunk_offset_per_track
					log MEMORY_FILE chunk_offset_per_track chunk_size_per_track
					for i = 0 < total_number_of_chunks
						get chunk_offset long MEMORY_FILE
						xmath full_chunk_offset "chunk_offset + (chunk_size_per_track + 0x30)"
						get next_chunk_offset long MEMORY_FILE
						goto -4 MEMORY_FILE SEEK_CUR
						xmath full_chunk_size "next_chunk_offset - chunk_offset"
						putarray 1 i full_chunk_offset
						putarray 2 i full_chunk_size
					next i
				endif
				math chunk_position + chunk_size_per_track
				log MEMORY_FILE 0 0
			else
				for i = 0 < total_number_of_chunks
					getarray full_chunk_offset 1 i
					getarray full_chunk_size 2 i
					log MEMORY_FILE full_chunk_offset full_chunk_size
					math chunk_position_on_memory = 0
					do
						goto chunk_position_on_memory MEMORY_FILE
						get chunk_track_number long MEMORY_FILE
						if chunk_track_number == 3
							get height short MEMORY_FILE
							get width short MEMORY_FILE
							get chunk_track_size long MEMORY_FILE
							get mpeg2_04 long MEMORY_FILE
						else
							get chunk_track_size long MEMORY_FILE
							get chunk_track_sub_number long MEMORY_FILE
							get chunk_track_04 long MEMORY_FILE
						endif
						savepos chunk_offset_per_track MEMORY_FILE
						callfunction extract_chunk 1
						math chunk_position_on_memory + 16
						math chunk_position_on_memory + chunk_track_size
					while chunk_position_on_memory < full_chunk_size
					math chunk_position = full_chunk_offset
					log MEMORY_FILE 0 0
				next i
				break
			endif
			math chunk_position + 16
		while chunk_position < DAT_SIZE
	endif

	if single_dat_type == 5
		get dat_02 long
		get dat_03 long
		get dat_04 long
		get dat_05 long
		get dat_06 long
		get dat_07 long
		get dat_08 long
		savepos chunk_position
		math chunks = 0
		do
			goto chunk_position
			get chunk_track_number long
			math chunks + 1
			if chunk_track_number == 3
				get height short
				get width short
				get chunk_track_size long
				get mpeg2_04 long
			else
				get chunk_track_size long
				get chunk_track_sub_number long
				get chunk_track_actual_size long
			endif
			get padding_01 long
			get padding_02 long
			get padding_03 long
			get padding_04 long
			savepos chunk_offset_per_track
			callfunction extract_chunk 1
			math chunk_position + 32
			if chunk_track_number == 1
				math chunk_track_size = 0
			elif chunk_track_number == 6
				math chunk_track_size = 0
			endif
			math chunk_position + chunk_track_size
		while chunk_position < DAT_SIZE
	endif
endif

startfunction extract_chunk
	# single .dat movie files like to do things differently
	append
	if chunk_track_number == 4
		if chunk_track_sub_number == 0xffffff00
			string chunk_name p "%s.pcm" NAME
		elif chunk_track_sub_number == 0xffffff01
			string chunk_name p "%s.ac3" NAME
		elif chunk_track_sub_number == 0xffffff02
			string chunk_name p "%s.adpcm" NAME
		elif chunk_track_sub_number == 0xffffff03
			string chunk_name p "%s.vsf" NAME
		endif
		if single_dat_type == 1
			log chunk_name chunk_offset_per_track chunk_track_size MEMORY_FILE
		elif single_dat_type == 5
			log chunk_name chunk_offset_per_track chunk_track_actual_size
		endif
	endif
	append
endfunction
