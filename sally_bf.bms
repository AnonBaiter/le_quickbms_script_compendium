# Ubisoft - .bf
# --- "BIG", "BUG" ---
# Beyond Good and Evil
# Prince of Persia: The Sands of Time
# Prince of Persia: Warrior Within
# Prince of Persia: Revelations
# Peter Jackson's King Kong: The Official Game of the Movie
# Prince of Persia: The Two Thrones
# Rayman Raving Rabbids
# TMNT
# Prince of Persia: Rival Swords
# My Word Coach
# Petz: Horsez 2
# Rayman Raving Rabbids 2
# My Spanish Coach
# My French Coach
# Imagine Champion Rider
# Petz: Horse Club
# Rayman Raving Rabbids: TV Party
# Cloudy with a Chance of Meatballs
# Just Dance
# James Cameron's Avatar: The Game
# Prince of Persia: The Forgotten Sands
# NCIS
# --- "ABE" ---
# Rabbids Go Home
# Red Steel 2
# Just Dance 2
# Raving Rabbids: Travel in Time
# Michael Jackson: The Experience
# Just Dance 2: Extra Songs, Just Dance: Summer Party
# Just Dance 3
# The Adventures of Tintin: The Game, The Adventures of Tintin: The Secret of the Unicorn
# The Black Eyed Peas Experience
# ABBA: You Can Dance
# Just Dance: Best of
# Just Dance: Greatest Hits
# Just Dance 4
# --- "BF64" ---
# Shaun White Skateboarding
# (and possibly others that use either of these three formats)

math 32bit_max_number = 0xffffffff

get bf_size asize
get bf_name basename
get bf_ext extension

# special cases of split bf files (incomplete list)
# Beyond Good and Evil (Xbox) - .bf# (starts with 0)
# Peter Jackson's King Kong: The Official Game of the Movie (Xbox) - .### (starts with 1)
# these will be handled in the near future

endian little

get bf_01 long
xmath bf_01_01 "(bf_01 & 0xff) << 24 | (bf_01 & 0xff00) << 8 | (bf_01 & 0xff0000) >> 8 | (bf_01 & 0xff000000) >> 24"
xmath bigfile_sign "(bf_01_01 >> 8) & 0xffffff"
math entry_info_size = 0
if bigfile_sign == 0x424947 # "BIG"
	log MEMORY_FILE 4 4 # put initial header data into memory
	math file_number = -1
	math entry_info_size_01 = 0x54
	math entry_info_size_02 = 0x54
	callfunction read_bigfile_header 1
elif bigfile_sign == 0x425547 # "BUG"
	math entry_info_size_01 = 0x54
	math entry_info_size_02 = 0x54
	callfunction decrypt_bigfile_header 1
elif bigfile_sign == 0x414245 # "ABE"
	callfunction read_abe_header 1
endif
xmath bf64_sign "bf_01_01 & 0xffffffff"
if bf64_sign == 0x42463634 # "BF64"
	callfunction read_bf64_header 1
endif

startfunction read_bf64_header
	get bf64_01 long
	get files long
	get folders long
endfunction

startfunction read_bigfile_header
	get bigfile_parameters long file_number
	# (todo) explore "bigfile_parameters" much further.
	# every .bf file that i've observed behaves like this:
	# if the .bf file is encrypted, then bigfile_parameters is set to 0x24 without exception.
	# but the thing is, the four variables that reside at offset 16 are pretty much
	# the first step of the "header decryption" process that is already covered here,
	# so bigfile_parameters might already be out of the question just as much
	# as the "bigfile" signature that is handled above.
	# perhaps there is a way to handle the decryption process
	# more efficiently without relying on bigfile_sign...
	if bigfile_parameters == 0x24
		math entry_info_size_01 + 4
	elif bigfile_parameters == 0x2a
		math entry_info_size_01 + 0x28
	elif bigfile_parameters == 0x2b
		math entry_info_size_01 + 0x2c
	elif bigfile_parameters == 0x2c
		math entry_info_size_01 + 0x28
	endif
	if bf_name == "avatar_bin_wii"
		math entry_info_size_01 + 0x40
		math entry_info_size_02 + 0x40
	endif
	if bigfile_parameters == 0x2c
		log MEMORY_FILE 8 0x50
		math file_index_header_offset = 0x58
	else
		log MEMORY_FILE 8 0x24
		math file_index_header_offset = 0x2c
	endif
	math file_number = -1
	goto 0 file_number
	get files1 long file_number
	get folders1 long file_number
	# they're needed for header decryption, see decrypt_bigfile_header
	get normal_key_01 long file_number
	get normal_key_02 long file_number
	get inverted_key_01 long file_number
	get inverted_key_02 long file_number
	get skips1 long file_number
	get file_indices long file_number
	# bigfile_parameters 0x2c has tons of assigned hashes for certain files instead.
	if bigfile_parameters == 0x2c
		get Univers_oin long file_number
		get unknown_hash_02 long file_number
		get versiontag_bin long file_number
	endif
	# flagship_file however stays here regardless...
	get flagship_file long file_number
	if bigfile_parameters == 0x2c
		get bigfile_unknown_04 long file_number
		get bigfile_unknown_05 long file_number
		get bigfile_unknown_06 long file_number
		get bigfile_unknown_07 long file_number
		get bigfile_unknown_08 long file_number
		get ps2_new_ico long file_number
		get Logo_loading_bin long file_number
		get bigfile_unknown_11 long file_number
	endif
	math file_index_header_size = 0x18
	if bigfile_sign == 0x424947 # "BIG"
		log MEMORY_FILE2 file_index_header_offset file_index_header_size
		math file_number = -2
	elif bigfile_sign == 0x425547 # "BUG"
		goto file_index_header_offset
		putvarchr MEMORY_FILE2 file_index_header_size 0
		xmath passes "file_index_header_size / 4"
		math file_number = -2
		callfunction decrypt_block 1
	endif
	goto 0 file_number
	for i = 0 < file_indices
		log MEMORY_FILE3 0 0
		log MEMORY_FILE4 0 0
		log MEMORY_FILE5 0 0
		get files2 long file_number
		get folders2 long file_number
		get file_listing_offset long file_number
		get next_listing_offset long file_number
		get bf_16 long file_number
		get skips2 long file_number
		xmath file_listing_size "files2 * 8"
		xmath file_tab_offset "file_listing_offset + (skips1 * 8)"
		xmath file_tab_size "files2 * entry_info_size_01"
		xmath folder_tab_offset "file_tab_offset + (skips1 * entry_info_size_01)"
		xmath folder_tab_size "folders2 * entry_info_size_02"
		if bigfile_sign == 0x424947 # "BIG"
			log MEMORY_FILE3 file_listing_offset file_listing_size
			math file_number = -3
			callfunction initialize_file_listing 1
			log MEMORY_FILE4 file_tab_offset file_tab_size
			math file_number = -4
			callfunction parse_file_tabs 1
			log MEMORY_FILE5 folder_tab_offset folder_tab_size
			math file_number = -5
			callfunction parse_folder_tabs 1
		elif bigfile_sign == 0x425547 # "BUG"
			goto file_listing_offset
			putvarchr MEMORY_FILE3 file_listing_size 0
			xmath passes "files2 * 4"
			math file_number = -3
			callfunction decrypt_block 1
			goto 0 file_number
			callfunction initialize_file_listing 1
			goto file_tab_offset
			putvarchr MEMORY_FILE4 file_tab_size 0
			math file_number = -4
			xmath passes "file_tab_size / 4"
			callfunction decrypt_block 1
			goto 0 file_number
			callfunction parse_file_tabs 1
			goto folder_tab_offset
			putvarchr MEMORY_FILE5 folder_tab_size putvarchr
			math file_number = -5
			xmath passes "folder_tab_size / 4"
			callfunction decrypt_block 1
			goto 0 file_number
			callfunction parse_folder_tabs 1
		endif
		callfunction final_step 1
		if next_listing_offset != 32bit_max_number	
			log MEMORY_FILE2 0 0
			math next_listing_offset - file_index_header_size
			if bigfile_sign == 0x424947 # "BIG"
				log MEMORY_FILE2 next_listing_offset file_index_header_size
				math file_number = -2
				goto 0 file_number
			elif bigfile_sign == 0x425547 # "BUG"
				goto next_listing_offset
				putvarchr MEMORY_FILE2 file_index_header_size 0
				xmath passes "file_index_header_size / 4"
				math file_number = -2
				callfunction decrypt_block 1
				goto 0 file_number
			endif
		endif
	next i
endfunction

startfunction initialize_file_listing
	for i1 = 0 < files2
		get file_01 long file_number
		putarray 0 i1 file_01
		get file_02 long file_number
		putarray 1 i1 file_02
	next i1
endfunction

startfunction parse_file_tabs
	for i1 = 0 < files2
		get file_03 long file_number
		putarray 2 i1 file_03
		get file_04 long file_number
		putarray 3 i1 file_04
		get file_05 long file_number
		putarray 4 i1 file_05
		get file_06 long file_number
		putarray 5 i1 file_06
		get file_07 time file_number
		putarray 6 i1 file_07
		callfunction fetch_entry_name 1
		set file_08 string entry_name
		putarray 7 i1 file_08
		if bigfile_parameters == 0x24
			get file_09 long file_number
			putarray 8 i1 file_09
		endif
		if bigfile_parameters >= 0x2a
			get file_09 long file_number
			putarray 8 i1 file_09
			getdstring file_10 0x20 file_number
			putarray 9 i1 file_10
			get file_11 long file_number
			putarray 10 i1 file_11
			if bigfile_parameters == 0x2b
				get file_12 long file_number
				putarray 11 i1 file_12
			endif
		endif
	next i1
endfunction

startfunction parse_folder_tabs
	for i2 = 0 < folders2
		get folder_01 long file_number
		putarray 32 i2 folder_01
		get folder_02 long file_number
		putarray 33 i2 folder_02
		get folder_03 long file_number
		putarray 34 i2 folder_03
		get folder_04 long file_number
		putarray 35 i2 folder_04
		get folder_05 long file_number
		putarray 36 i2 folder_05
		callfunction fetch_entry_name 1
		set folder_06 string entry_name
		putarray 37 i2 folder_06
	next i2
endfunction

startfunction final_step
	if bigfile_sign == 0x414245 # "ABE"
		for i2 = 0 < folders2
			set full_folder_name string ""
			getarray folder_name 32 i2
			getarray previous_folder 33 i2
			getarray next_folder 34 i2
			getarray neighbor_folder 35 i2
			getarray flagship_title 36 i2
			getarray folder_06 37 i2
			math keyword_number = 0
			putarray 64 keyword_number folder_name
			math keyword_number + 1
			if previous_folder != 32bit_max_number
				for
					getarray folder_name 32 previous_folder
					getarray previous_folder 33 previous_folder
					putarray 64 keyword_number folder_name
					math keyword_number + 1
					if previous_folder == 32bit_max_number
						break
					endif
				next
			endif
			math max_names_for_this_folder = keyword_number
			xmath name_startoff "keyword_number - 1"
			for nk = 0 < max_names_for_this_folder
				getarray folder_name 64 name_startoff
				math name_startoff - 1
				string full_folder_name + folder_name
				string full_folder_name + "/"
			next nk
			putarray 38 i2 full_folder_name
		next i2

		for i1 = 0 < files2
			set full_file_name string ""
			getarray file_name 0 i1
			getarray file_02 1 i1
			getarray folder_number 2 i1
			getarray full_folder_name 38 folder_number
			getarray file_04 3 i1
			getarray encapsulated_size 4 i1
			getarray file_timestamp 5 i1
			getarray file_name_hash 6 i1
			getarray file_08 7 i1
			getarray file_offset 8 i1
			getarray block_size 9 i1
			getarray file_size 10 i1
			getarray file_12 11 i1
			getarray file_13 12 i1
			getarray file_14 13 i1
			getarray file_15 14 i1
			getarray file_16 15 i1
			string full_file_name + full_folder_name
			string full_file_name + file_name
			goto file_offset
			get compressed_file_size long
			get original_file_size long
			xmath real_file_offset "file_offset + 0x20"
		next i1
	else
		for i2 = 0 < folders2
			set full_folder_name string ""
			getarray folder_01 32 i2
			getarray next_folder 33 i2
			getarray next_neighbor_folder 34 i2
			getarray previous_neighbor_folder 35 i2
			getarray previous_folder 36 i2
			getarray folder_name 37 i2
			math keyword_number = 0
			putarray 64 keyword_number folder_name
			math keyword_number + 1
			if previous_folder != 32bit_max_number
				for
					getarray previous_folder 36 previous_folder
					getarray folder_name 37 previous_folder
					putarray 64 keyword_number folder_name
					math keyword_number + 1
					if previous_folder == 0
						break
					endif
				next
			endif
			math max_names_for_this_folder = keyword_number
			xmath name_startoff "keyword_number - 1"
			for nk = 0 < max_names_for_this_folder
				getarray folder_name 64 name_startoff
				math name_startoff - 1
				string full_folder_name + folder_name
				string full_folder_name + "/"
			next nk
			putarray 38 i2 full_folder_name
		next i2

		for i1 = 0 < files2
			set full_file_name string ""
			getarray file_offset 0 i1
			getarray file_name_hash 1 i1
			getarray file_size 2 i1
			getarray next_neighbor_file 3 i1
			getarray previous_neighbor_file 4 i1
			getarray folder_number 5 i1
			getarray full_folder_name 38 folder_number
			getarray file_time_record 6 i1
			getarray file_name 7 i1
			if bigfile_parameters == 0x24
				getarray file_09 8 i1
			endif
			if bigfile_parameters >= 0x2a
				getarray file_09 8 i1
				getarray file_sha1 9 i1
				getarray file_11 10 i1
				if bigfile_parameters == 0x2b
					getarray file_12 11 i1
				endif
			endif
			string full_file_name + full_folder_name
			string full_file_name + file_name
			putarray 11 i1 full_file_name
			goto file_offset
			get real_file_size long
			savepos real_file_offset
			# (todo) adjust the file size by ratting out the padding
			log full_file_name real_file_offset real_file_size
		next i1
	endif
endfunction

startfunction decrypt_bigfile_header
	goto 0x10
	get normal_key_01 long
	get normal_key_02 long
	get inverted_key_01 long
	get inverted_key_02 long
	if normal_key_01 == normal_key_02
		# 0 for both variables
		math normal_key == normal_key_02
	endif
	if inverted_key_01 == inverted_key_02
		# -1 for both variables
		math inverted_key == inverted_key_02
	endif
	goto 4
	log MEMORY_FILE 4 0x28
	xmath passes "0x28 / 4"
	math file_number = -1
	callfunction decrypt_block 1
	goto 0 file_number
	callfunction read_bigfile_header 1
endfunction

startfunction decrypt_block
	for pass = 0 < passes
		get target long
		xmath decoded "target ^ normal_key"
		put decoded long file_number
	next pass
endfunction

startfunction fetch_entry_name
	if bf_name == "avatar_bin_wii"
		getdstring entry_name 0x80 file_number
	else
		getdstring entry_name 0x40 file_number
	endif
endfunction

startfunction read_abe_header
	get abe_01 long
	get abe_02 long
	get file_tabs long
	get folder_tabs long
	get abe_05 long
	get file_tab_offset long
	get abe_07 long
	get folder_tab_offset long
	get files1 long
	get folders1 long
	get files2 long
	get folders2 long
	get abe_13 long
	get abe_14 long
	get abe_15 long
	goto file_tab_offset
	math tab_type = 1
	math tabs = file_tabs
	callfunction read_abe_tab 1
	goto folder_tab_offset
	math tab_type = 2
	math tabs = folder_tabs
	callfunction read_abe_tab 1
	callfunction final_step 1
endfunction

math file = 0
math folder = 0
startfunction read_abe_tab
	for i = 0 < tabs
		get entries long
		get tab_02 long
		get tab_03 long
		if tab_02 == 0
			math next_index_offset = tab_03
		endif
		math file_number = 0
		if tab_type = 1
			callfunction parse_file_tabs_02 1
		elif tab_type = 2
			callfunction parse_folder_tabs_02 1
		endif
		if tab_02 == 0
			goto next_index_offset
		endif
	next i
endfunction

startfunction parse_file_tabs_02
	for i1 = 0 < entries
		callfunction fetch_entry_name 1
		set file_01 string entry_name
		putarray 0 file file_01
		getdstring file_02 0x10 file_number
		putarray 1 file file_02
		get file_03 long file_number
		putarray 2 file file_03
		get file_04 long file_number
		putarray 3 file file_04
		get file_05 long file_number
		putarray 4 file file_05
		get file_06 time64 file_number
		putarray 5 file file_06
		get file_07 long file_number
		putarray 6 file file_07
		get file_08 long file_number
		putarray 7 file file_08
		get file_09 long file_number
		putarray 8 file file_09
		get file_10 long file_number
		putarray 9 file file_10
		get file_11 long file_number
		putarray 10 file file_11
		get file_12 long file_number
		putarray 11 file file_12
		get file_13 long file_number
		putarray 12 file file_13
		get file_14 long file_number
		putarray 13 file file_14
		get file_15 long file_number
		putarray 14 file file_15
		getdstring file_16 0x40 file_number
		putarray 15 file file_16
		math file + 1
		if file == files2
			break
		endif
	next i1
endfunction

startfunction parse_folder_tabs_02
	for i2 = 0 < entries
		callfunction fetch_entry_name 1
		set folder_01 string entry_name
		putarray 32 folder folder_01
		get folder_02 long file_number
		putarray 33 folder folder_02
		get folder_03 long file_number
		putarray 34 folder folder_03
		get folder_04 long file_number
		putarray 35 folder folder_04
		get folder_05 long file_number
		putarray 36 folder folder_05
		get folder_06 long file_number
		putarray 37 folder folder_06
		getdstring folder_07 0x10 file_number
		putarray 38 folder folder_07
		math folder + 1
		if folder == folders2
			break
		endif
	next i2
endfunction
